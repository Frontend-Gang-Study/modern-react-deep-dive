# 3. 리액트 훅 깊게 살펴보기

**훅**: 함수 컴포넌트에서 상태를 사용하거나, 클래스 컴포넌트의 생명주기 메서드를 대체하는 기능

## 3.1 리액트의 모든 훅 파헤치기

### 3.1.1 useState

상태를 정의하고, 상태를 관리할 수 있게 해주는 훅.

#### useState 구현 살펴보기

```jsx
const [state, setState] = useState(initialState);
```

아래 코드를 보자. 아래 코드가 리렌더링이 될까?

```jsx
function Componet() {
  const [, triggerRender] = useState();

  let state = "hello";

  function handleClick() {
    state = "world";
    triggerRender();
  }

  return <button onClick={handleClick}>{state}</button>;
}
```

useState 반환값의 두 번째 원소를 실행해 렌더링이 일어나게끔 했지만 state 값이 변경되지 않았다. 이 이유는 무엇일까?

useState 훅은 렌더링 시점에 초기화된 값을 반환한다. 따라서 위 코드에서 state 값은 초기화된 값인 'hello'를 반환한다.

[ 예상되는 useState 훅을 가볍게 구현한 코드 ]

```jsx
function useState(initialState) {
  let internalState = initialState;

  function state() {
    return internalState;
  }

  function setState(newState) {
    internalState = newState;
  }

  return [state, setState];
}
```

위 코드에서 state 함수는 현재 상태를 반환하고, setState 함수는 상태를 업데이트한다.

이 코드를 실행하면 버튼을 눌렀을 때 상태가 변경되어 버튼 텍스트가 'world'로 변경되어야 한다.

[ 실제 리액트의 useState 훅과 유사하게 구현한 코드 ]

실제 리액트는 클로저를 이용해 위 코드를 구현한다. 실제 코드는 useReducer 훅을 이용해 구현되어 있다. 아래 코드는 실제 리액트의 useState 훅과 유사하게 구현한 코드이다.

```jsx
const MyReact = (function() {
	const global = {};
	let index = 0;

	function useState(initialState) {
		if (!global.states) {
			global.states = [];
		}

		// 현재 index에 해당하는 상태가 없으면 초기값을 할당한다.
		const currentState = global.states[index] || initialState;
		global.states[index] = currentState;

		const setState = (function() => {
			// 현재 index를 클로저로 가둬놔서 이후에도 계속해서 동일한 index에 접근할 수 있다.
			let currentIndex = index;
			return function (value) {
				global.states[currentIndex] = value;
				render();
			}
		})();

		index++;

		return [currentState, setState];
	}

	function Component() {
		const [state, setState] = useState(0);
		//...
	}
})()
```

이렇듯 클로저에 의존해 구현돼 있을 것이라 짐작할 수 있다. 클로저를 사용해 외부에 해당 값을 노출시키지 않고, 함수 컴포넌트가 매번 실행되더라도 useState에서 이전의 값을 정확하게 꺼내 쓸 수 있도록 한다.

#### 게으른 초기화

```jsx
// 바로 값을 집어넣는다.
const [state, setState] = useState(
  Number.parseInt(window.localStorage.getItem(cacheKey))
);

// lazy initialization
// 함수를 실행해 값을 초기화한다.
const [state, setState] = useState(() =>
  Number.parseInt(window.localStorage.getItem(cacheKey))
);
```

리액트 공식 문서에서 이러한 게으른 초기화는 useState의 초깃값이 복잡하거나 무거운 연산을 포함하고 있을 때 사용하라고 돼 있다. 이 게으른 초기화 함수는 오로지 컴포넌트가 처음 렌더링될 때만 실행된다. (리렌더링 시에는 실행되지 않는다.)

**언제 사용하면 좋을까?**

- localStorage, sessionStorage 접근
- map, filter, find 등 배열 접근
- 초기값 계산을 위해 함수 호출이 필요한 경우(무거운 연산)

### 3.1.2 useEffect

useEffect는 생명주기 메서드를 대체하기 위해 만들어진 훅은 아니다.

정의: useEffect는 애플리케이션 내 컴포넌트의 여러 값들을 활용해 동기적으로 부수 효과를 만드는 메커니즘이다. '언제' 일어나는지보다 어떤 상태값과 함께 실행되는지가 더 중요하다.

#### useEffect란?

첫 번째 인수: 부수 효과가 포함된 함수
두 번째 인수: 의존성 배열

의존성 배열이 변경될 때마다 첫 번째 인수로 전달한 함수가 실행된다.

useEffect는 의존성의 값이 이전과 다른 게 하나라도 있으면 부수 효과를 실행하는 평범한 함수이다.

따라서 state와 props의 변화 속에서 일어나는 렌더링 과정에서 실행되는 부수 효과 함수라고 정의할 수 있다.

#### 클린업 함수의 목적

클린업 함수는 이전 state를 참조해 실행된다. 새로운 값과 함께 렌더링된 뒤에 실행되지만 변경된 값을 읽는 것은 아니다.

함수가 정의됐을 당시에 선언됐던 이전 값을 보고 실행된다.

이 사실을 종합해 보면 useEffect에 이벤트를 추가했을 때 왜 클린업 함수에서 지워야 하는지 이해할 수 있다.

useEffect 콜백이 실행될 때마다 이전의 클린업 함수가 존재한다면 클린업 함수를 실행한 뒤에 콜백을 실행한다. 따라서 이벤트를 추가하기 전에 이전에 등록했던 이벤트 핸들러를 삭제하는 코드를 클린업 함수에 추가하는 것이다. 이렇게 함으로써 특정 이벤트의 이벤트 핸들러가 중복 등록되는 것을 방지할 수 있다.

이처럼 클린업 함수는 언마운트 개념과는 조금 차이 있다.

**클린업 함수는 언마운트라기보다는 함수 컴포넌트가 리렌더링 됐을 때 이전 상태값을 기준으로 실행된다는 것을 기억하자.**

#### 의존성 배열

빈 배열로 둔다면 비교할 의존성이 없다고 판단해 렌더링 시에만 실행된다.

그렇다면, 의존성 배열이 없는 useEffect가 매 렌더링마다 실행된다면 그냥 useEffect 없이 써도 되는 게 아닐까?

```jsx
function Component() {
  console.log("렌더링 됐어요");
}

function Component2() {
  useEffect(() => {
    console.log("렌더링 됐어요");
  });
}
```

두 코드의 차이점

1. 서버 사이드 렌더링 관점에서 useEffect는 클라이언트 사이드에서 실행되는 것을 보장해 준다. useEffect 내부에서는 window 객체의 접근에 의존하는 코드를 사용해도 된다.
2. useEffect는 컴포넌트 렌더링의 부수 효과, 즉 렌더링이 완료된 이후에 실행된다. 반면 1번과 같이 함수 내부에서의 직접 실행은 렌더링 도중에 실행된다. 따라서 2번과 달리 서버 사이드 렌더링의 경우에 서버에서도 실행된다. 그리고 이 작업은 함수 컴포넌트의 반환을 지연시키는 행위다. 즉 무거운 작업일 경우 렌더링을 방해하므로 성능에 악영향을 미칠 수 있다.

✅ **useEffect는 컴포넌트가 렌더링된 후에 어떠한 부수 효과를 일으키고 싶을 때 사용하는 훅이라는 걸 명심하자.**

#### useEffect를 사용할 때 주의할 점

`eslint-disable-line react-hooks/exhaustive-deps` 주석은 최대한 자제하라

useEffect는 반드시 의존성 배열로 전달한 값의 변경에 의해 실행돼야 하는 훅이다.

정말로 의존성으로 []가 필요하다면 최초에 함수 컴포넌트가 마운트됐을 시점에만 콜백 함수 실행이 필요한지를 다시 한번 확인하자.

useEffect의 빈 배열을 넘기기 전에 정말로 useEffect의 부수 효과가 컴포넌트의 상태와 별개로 작동해야만 하는지, 혹은 여기서 호출하는 게 최선인지 검토하자.

#### useEffect의 첫 번째 인수에 함수명을 부여하라

useEffect의 코드가 복잡하고 많아질수록 무슨 일을 하는지 파악하기 어렵다. **적절한 기명함수로 만들면 변수의 목적을 파악하기 쉽다.**

#### 거대한 useEffect를 만들지 마라

가능한 간결하고 가볍게 유지하자. 부득이하게 큰 useEffect를 만들어야 한다면, 작은 단위로 useEffect를 분리하자.

만약 의존성 배열에 불가피하게 여러 변수가 들어가야 하는 상황이라면 최대한 useCallback과 useMemo 등으로 사전에 정제한 내용들만 useEffect에 담아두는 것이 좋다. 이렇게 하면 언제 useEffect가 실행되는지 좀 더 명확하게 알 수 있다.

#### 불필요한 외부 함수를 만들지 마라

크기가 작은 것과 같은 맥락에서 useEffect가 실행하는 콜백 또한 불필요하게 존재해서는 안된다. useEffect 밖에 함수를 선언하면 불필요한 코드가 많아지고 가독성이 떨어질 수 있다. useEffect 내에서 사용할 부수 효과라면 내부에서 만들어서 정의해서 사용하는 편이 훨씬 도움이 된다.

> 왜 useEffect의 콜백 인수로 비동기 함수를 바로 넣을 수 없을까?
>
> useEffect에서 비동기로 함수를 호출하는 경우 경쟁 상태가 발생할 수 있어서 순서를 보장할 수 없게 된다.
> 하지만, useEffect 내부에서 비동기 함수를 선언해서 실행하거나 즉시 실행 비동기 함수를 만들어서 사용하는 것은 가능하다.

### 3.1.3 useMemo

useMemo는 비용이 큰 연산에 대한 결과를 저장(메모이제이션)해 두고, 이 저장된 값을 반환하는 훅이다.

```jsx
import { useMemo } from "react";

const memoizedValue = useMemo(() => expensiveComputation(a, b, [a, b]));
```

- 첫번째 인수: 어떠한 값을 반환하는 생성 함수
- 두번째 인수: 의존하는 값의 배열

의존성 배열의 값이 변경됐다면 첫 번째 인수의 함수를 실행한 후에 그 값을 반환하고 그 값을 다시 기억해 둘 것이다.

**useMemo로 컴포넌트도 메모이제이션할 수 있다. 하지만 `React.memo`를 쓰는 것이 더 현명하다.**

'비용이 많이 드는 연산'을 막을 수 있다는 장점이 있다.

### 3.1.4 useCallback

useMemo가 값을 기억한다면, useCallback은 인수로 넘겨받은 콜백 자체를 기억한다.

특정 함수를 새로 만들지 않고 다시 재사용한다는 의미다.

useCallback을 추가하면 해당 의존성이 변경됐을 때만 함수가 재생성된다. 불필요한 함수 재생성을 막아 리렌더링을 방지하고 싶을 때 사용하자.

- **TIP**: 기명함수로 만들면 크롬 개발자 도구에서 디버깅하기 편하다.

**useCallback은 useMemo를 사용해서 구현할 수 있다.**

```jsx
export function useCallback(callback, args) {
  currentHook = 8;
  return useMemo(() => callback, args);
}
```

**아래 두 함수의 작동은 동일하다.**

```jsx
const handleClick1 = useCallback(() => {
	setCounter((prev) => prev + 1)
}, [])

const handleClick1 = useMemo(() => {
	return () => setCounter((prev) => prev + 1)
}, [])
```

> 기억해야할 점! - `useCallback`, `useMemo`는 동일한 역할을 한다.

### 3.1.5 useRef

useState 와 동일하게 렌더링이 일어나도 변경 가능한 상태값을 저장한다는 공통점이 있다.

**큰 차이점 두가지**

- useRef는 반환값인 객체 내부에 있는 current로 값에 접근 또는 변경할 수 있다.
- useRef는 그 값이 변하더라도 렌더링을 발생시키지 않는다.


**생각해보기**: useRef대신 컴포넌트 외부에 값을 둔다면?

컴포넌트가 렌더링되지 않았음에도 외부의 변수가 기본적으로 존재함. 이는 메모리에 불필요한 값을 갖게하는 악영향을 미친다.

그리고 컴포넌트가 여러 번 생성된다면 각 컴포넌트에서 가리키는 값이 모두 동일한 변수일 것이다. 대부분의 경우 컴포넌트 인스턴스 하나당 하나의 값을 필요로 할 것이다.

**일반적인 사용은 DOM에 접근하고 싶을 때 이다.**

useRef를 사용할 수 있는 유용한 경우는, useState의 이전 값을 저장하는 usePrevious() 같은 훅을 구현할 때다.

```jsx
usePrevious(value) {
	const ref = useRef()

	useEffect(() => {
		ref.current = value
	}, [value]) // value가 변경되면 그 값을 ref에 넣어둔다.
	return ref.current
}

function SomeComponent() {
	const [counter, setCounter] = useState(0)
	const previousCounter = usePrevious(counter)

	function handleClick() {
		setCounter((prev) => prev + 1)
	}

	return (
		<button onClick={handleClick}>{counter} {previousCounter} </button>
	)
}
```

**useRef 구현**

```jsx
export function useRef(initialValue) {
	currentHook = 5
	return useMemo(() => ({ current: initialValue }), [])
}
```

값이 변경돼도 렌더링되면 안된다는 점, 실제 값은 객체 형태로 있다는 점을 떠올려보자.

렌더링에 영향을 미치면 안 되기 때문에 useMemo에 의도적으로 빈 배열을 선언해 뒀고, 이는 각 렌더링마다 동일한 객체를 가리킬 것이다.

자바스크립트 특징, 객체의 값을 변경해도 객체를 가리키는 주소가 변경되지 않는다는 것을 떠올리면 useMemo로 useRef를 구현할 수 있다.

### 3.1.6 useContext


