# 3. 리액트 훅 깊게 살펴보기

**훅**: 함수 컴포넌트에서 상태를 사용하거나, 클래스 컴포넌트의 생명주기 메서드를 대체하는 기능

## 3.1 리액트의 모든 훅 파헤치기

### 3.1.1 useState

상태를 정의하고, 상태를 관리할 수 있게 해주는 훅.

#### useState 구현 살펴보기

```jsx
const [state, setState] = useState(initialState);
```

아래 코드를 보자. 아래 코드가 리렌더링이 될까?

```jsx
function Componet() {
  const [, triggerRender] = useState();

  let state = "hello";

  function handleClick() {
    state = "world";
    triggerRender();
  }

  return <button onClick={handleClick}>{state}</button>;
}
```

useState 반환값의 두 번째 원소를 실행해 렌더링이 일어나게끔 했지만 state 값이 변경되지 않았다. 이 이유는 무엇일까?

useState 훅은 렌더링 시점에 초기화된 값을 반환한다. 따라서 위 코드에서 state 값은 초기화된 값인 'hello'를 반환한다.

[ 예상되는 useState 훅을 가볍게 구현한 코드 ]

```jsx
function useState(initialState) {
  let internalState = initialState;

  function state() {
    return internalState;
  }

  function setState(newState) {
    internalState = newState;
  }

  return [state, setState];
}
```

위 코드에서 state 함수는 현재 상태를 반환하고, setState 함수는 상태를 업데이트한다.

이 코드를 실행하면 버튼을 눌렀을 때 상태가 변경되어 버튼 텍스트가 'world'로 변경되어야 한다.

[ 실제 리액트의 useState 훅과 유사하게 구현한 코드 ]

실제 리액트는 클로저를 이용해 위 코드를 구현한다. 실제 코드는 useReducer 훅을 이용해 구현되어 있다. 아래 코드는 실제 리액트의 useState 훅과 유사하게 구현한 코드이다.

```jsx
const MyReact = (function() {
	const global = {};
	let index = 0;

	function useState(initialState) {
		if (!global.states) {
			global.states = [];
		}

		// 현재 index에 해당하는 상태가 없으면 초기값을 할당한다.
		const currentState = global.states[index] || initialState;
		global.states[index] = currentState;

		const setState = (function() => {
			// 현재 index를 클로저로 가둬놔서 이후에도 계속해서 동일한 index에 접근할 수 있다.
			let currentIndex = index;
			return function (value) {
				global.states[currentIndex] = value;
				render();
			}
		})();

		index++;

		return [currentState, setState];
	}

	function Component() {
		const [state, setState] = useState(0);
		//...
	}
})()
```

이렇듯 클로저에 의존해 구현돼 있을 것이라 짐작할 수 있다. 클로저를 사용해 외부에 해당 값을 노출시키지 않고, 함수 컴포넌트가 매번 실행되더라도 useState에서 이전의 값을 정확하게 꺼내 쓸 수 있도록 한다.

#### 게으른 초기화

```jsx
// 바로 값을 집어넣는다.
const [state, setState] = useState(
  Number.parseInt(window.localStorage.getItem(cacheKey))
);

// lazy initialization
// 함수를 실행해 값을 초기화한다.
const [state, setState] = useState(() =>
  Number.parseInt(window.localStorage.getItem(cacheKey))
);
```

리액트 공식 문서에서 이러한 게으른 초기화는 useState의 초깃값이 복잡하거나 무거운 연산을 포함하고 있을 때 사용하라고 돼 있다. 이 게으른 초기화 함수는 오로지 컴포넌트가 처음 렌더링될 때만 실행된다. (리렌더링 시에는 실행되지 않는다.)

**언제 사용하면 좋을까?**

- localStorage, sessionStorage 접근
- map, filter, find 등 배열 접근
- 초기값 계산을 위해 함수 호출이 필요한 경우(무거운 연산)

### 3.1.2 useEffect

useEffect는 생명주기 메서드를 대체하기 위해 만들어진 훅은 아니다.

정의: useEffect는 애플리케이션 내 컴포넌트의 여러 값들을 활용해 동기적으로 부수 효과를 만드는 메커니즘이다. '언제' 일어나는지보다 어떤 상태값과 함께 실행되는지가 더 중요하다.

#### useEffect란?

첫 번째 인수: 부수 효과가 포함된 함수
두 번째 인수: 의존성 배열

의존성 배열이 변경될 때마다 첫 번째 인수로 전달한 함수가 실행된다.

useEffect는 의존성의 값이 이전과 다른 게 하나라도 있으면 부수 효과를 실행하는 평범한 함수이다.

따라서 state와 props의 변화 속에서 일어나는 렌더링 과정에서 실행되는 부수 효과 함수라고 정의할 수 있다.

#### 클린업 함수의 목적

클린업 함수는 이전 state를 참조해 실행된다. 새로운 값과 함께 렌더링된 뒤에 실행되지만 변경된 값을 읽는 것은 아니다.

함수가 정의됐을 당시에 선언됐던 이전 값을 보고 실행된다.

이 사실을 종합해 보면 useEffect에 이벤트를 추가했을 때 왜 클린업 함수에서 지워야 하는지 이해할 수 있다.

useEffect 콜백이 실행될 때마다 이전의 클린업 함수가 존재한다면 클린업 함수를 실행한 뒤에 콜백을 실행한다. 따라서 이벤트를 추가하기 전에 이전에 등록했던 이벤트 핸들러를 삭제하는 코드를 클린업 함수에 추가하는 것이다. 이렇게 함으로써 특정 이벤트의 이벤트 핸들러가 중복 등록되는 것을 방지할 수 있다.

이처럼 클린업 함수는 언마운트 개념과는 조금 차이 있다.

**클린업 함수는 언마운트라기보다는 함수 컴포넌트가 리렌더링 됐을 때 이전 상태값을 기준으로 실행된다는 것을 기억하자.**

#### 의존성 배열

빈 배열로 둔다면 비교할 의존성이 없다고 판단해 렌더링 시에만 실행된다.

그렇다면, 의존성 배열이 없는 useEffect가 매 렌더링마다 실행된다면 그냥 useEffect 없이 써도 되는 게 아닐까?

```jsx
function Component() {
  console.log("렌더링 됐어요");
}

function Component2() {
  useEffect(() => {
    console.log("렌더링 됐어요");
  });
}
```

두 코드의 차이점

1. 서버 사이드 렌더링 관점에서 useEffect는 클라이언트 사이드에서 실행되는 것을 보장해 준다. useEffect 내부에서는 window 객체의 접근에 의존하는 코드를 사용해도 된다.
2. useEffect는 컴포넌트 렌더링의 부수 효과, 즉 렌더링이 완료된 이후에 실행된다. 반면 1번과 같이 함수 내부에서의 직접 실행은 렌더링 도중에 실행된다. 따라서 2번과 달리 서버 사이드 렌더링의 경우에 서버에서도 실행된다. 그리고 이 작업은 함수 컴포넌트의 반환을 지연시키는 행위다. 즉 무거운 작업일 경우 렌더링을 방해하므로 성능에 악영향을 미칠 수 있다.

✅ **useEffect는 컴포넌트가 렌더링된 후에 어떠한 부수 효과를 일으키고 싶을 때 사용하는 훅이라는 걸 명심하자.**
