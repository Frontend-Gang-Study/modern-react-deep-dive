# 2장 리액트 핵심 요소 깊게 살펴보기

## 2.1 JSX란?

JSX는 페이스북이 임의로 만든 새로운 문법이다. 때문에 반드시 트랜스파일러를 거쳐야 자바스크립트 코드로 변환된다.

### 2.1.1 JSX 정의

기본적으로 JSXElement, JSXAttributes, JSXChildren, JSXStrings라는 4가지 컴포넌트를 기반으로 구성돼 있다.

- JSXElement
  - JSXOpeningElement: `<div>`
  - JSXClosingElement: `</div>`
  - JSXSelfClosingElement: `<br />`
  - JSXFragment: `<></>`

> 요소명은 대문자로 시작해야 하나요?
>
> 대문자로 시작하면 리액트 컴포넌트로 인식하고, 소문자로 시작하면 HTML 태그로 인식한다.

- JSXElementName: JSXElement의 이름을 나타내는 컴포넌트

  - JSXIdentifier: 내부에서 사용하는 식별자 `$`, `_` 로 시작할 수 있음. `<$></$>`
  - JSXNamespacedName: `namespace:name`, 두개의 식별자로 이루어짐. 그 이상은 불가능.
  - JSXMemberExpression: `props.name`, `:` 과 다르게 `.`을 여러 개 이어서 쓸 수 있음.

- JSXAttributes

  - JSXAttribute: name="value"
  - JSXSpreadAttribute: {...props} 전개 연산자와 동일한 역할

- JSXChildren

  - JSXChild: JSXChildren을 이루는 기본 단위. 0개 이상의 JSXChild가 존재할 수 있음.

    - JSXText: 문자열
    - JSXElemnet: 값으로 다른 JSX 요소가 들어갈 수 있음
    - JSXFragment: 빈 요소가 들어갈 수 있음
    - { JSXChildExpression (optional) }:

    ```jsx
    export default function App() {
      return <>{(() => "foo")()}</>;
    }
    ```

- JSXStrings: HTML에서 사용 가능한 문자열은 모두 사용 가능. `\`를 사용할 때만 `\\`로 작성해야 하는 것을 주의하자.

### 2.1.2 JSX 예제

```jsx
const ComponentA = () => <A {...{ required: true }} />;
const ComponentB = () => <A required={true} />;
const ComponentC = () => <A optionalChildren={<>안녕하세요</>} />;
```

```jsx
function ComponentA() { return <A.B></A.B> }
function ComponentB() { return <A.B.C></A.B.C> }
function ComponentC() { return <A:B.C></A:B.C> }
function ComponentD() { return <$></$> }
function ComponentE() { return <_></_> }
```

### 2.1.3 JSX는 어떻게 자바스크립트에서 변환될까?

```jsx
const ComponentA = () => <A {...{ required: true }}>Hello, world!</A>;
const ComponentB = () => <>Hello, world!</>;
```

@babel/plugin-tranform-react-jsx로 변환한 결과

```jsx
"use strict";
const ComponentA = React.createElement(A, { required: true }, "Hello, world!");
const ComponentB = React.createElement(React.Fragment, null, "Hello, world!");
```

리액트17, 바벨 7.9.0 이후 버전에서 추가된 자동 런타임으로 @babel/plugin-transform-react-jsx로 변환한 결과

```jsx
"use strict";

var _jsxRuntime = require("custom-jsx-runtime/jsx-runtime");
const ComponentA = (0, _jsxRuntime.jsx)(A, {
  required: true,
  children: "Hello, world!",
});
const ComponentB = (0, _jsxRuntime.jsx)(_jsxRuntime.Fragment, {
  children: "Hello, world!",
});
```

JSX가 변환되는 특성을 활용한다면 다음과 같이 코드 중복 없이 간결하게 처리할 수 있다.

```jsx
import { createElement } from "react";

function TextOrHeading({
  isHeading,
  children,
}): PropsWithChildren<{ isHeading: boolean }> {
  return createElement(
    isHeading ? "h1" : "span",
    { className: "text" },
    children
  );
}
```

### 2.1.4 정리

리액트에서 사용하지 않는 JSX 문법

- JSXNamespacedName
- JSXMemberExpression


## 2.2 가상 DOM과 리액트 파이버

### 2.2.1 DOM과 브라우저 렌더링 과정

1. 브라우저가 사용자가 요청한 주소를 방문해 HTML 파일을 다운로드한다.
2. 브라우저의 렌더링 엔진은 HTML을 파싱해 DOM 노드로 구성된 트리(DOM)를 만든다.
3. 2번 과정에서 CSS 파일을 만나면 해당 CSS 파일도 다운로드한다.
4. 브라우저의 렌더링 엔진은 이 CSS도 파싱해 CSS 노드로 구성된 트리(CSSOM)를 만든다.
5. 브라우저는 2번에서 만든 DOM 노드를 순회하는데, 여기서 모든 노드를 방문하는 것은 아니고 사용자 눈에 보이는 노드만 방문한다. 즉, display: none과 같이 사용자 화면에 보이지 않는 요소는 방문해 작업하지 않는다. 이는 트리를 분석하는 과정을 조금이라도 빠르게 하기 위해서다.
6. 5번에서 제외된, 눈에 보이는 노드를 대상으로 해당 노드에 대한 CSSOM 정보를 찾고 여기서 발견한 CSS 스타일 정보를 이 노드에 적용한다. 이 DOM 노드에 CSS를 적용하는 과정은 크게 두 가지로 나눌 수 있다.
  - 레이아웃(layout, reflow): 각 노드가 브라우저 화면의 어느 좌표에 정확히 나타나야 하는지 계산하는 과정. 이 레이아웃 과정을 거치면 반드시 페인팅 과정도 거치게 된다.
  - 페인팅(painting): 레이아웃 단계를 거친 노드에 색과 같은 실제 유효한 모습을 그리는 과정.
