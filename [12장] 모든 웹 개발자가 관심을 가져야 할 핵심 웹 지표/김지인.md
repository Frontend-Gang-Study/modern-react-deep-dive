-   성능에 대한 체감은 사용자별로 다름

-   웹 서비스도 게임 만큼 성능이 중요
        
	-   버그 없이 웹서비스를 운영하는 것도 중요하지만, **사용자가 쾌적하게 이용할 수 있는 것도 매우 중요**

#   12.1 웹 사이트와 성능

사용자가 웹사이트에 접속했을때 기대하는 사항

-   웹사이트를 방문한 목적을 손쉽게 달성
-   웹사이트의 보안 철저

리액트가 아무리 좋은 프레임워크라고 해도, 웹사이트의 성능이 뒤떨어지면 개발자를 제외한 실제 서비스 이용자들의 호응을 얻긴 어렵다.


**웹사이트 성능과 사용자 경험 사이의 상관관계에 대한 facts**

-   1초 내로 로딩되는 사이트는 5초 내로 로딩되는 사이트보다 전자상거래 전환율이 2.5배 더 높다
-   0~5초 범위에서, 로딩이 1초 늦어질수록 전환율을 4.42%씩 떨어진다.
-   페이지 로드 시간이 0~2초 사이인 페이지에서 가장 높은 전환율을 달성할 수 있다.
-   소비자의 70%는 페이지 속도가 온라인 커머스 사이트를 방문하는 데 영향을 미친다고 한다

	_라이트하우스 기다리는 동안 이런 얘기들 봄_

**구글에서 웹 사이트 성능에 관한 통계**

-   전체 웹페이지를 표시하는 데 필요한 최적의 평균 리소스 요청 수는 50회 미만이다
-   인간의 뇌와 신경계를 분석한 결과, 페이지 로드 시간이 1초에서 10초로 늘어날수록 모바일 사이트를 이탈할 확률이 123% 증가한다.

---
- 분명히 과거에 비해 모바일 기기의 성능이 향상됐고, 네트워크 속도도 빨라졌음에도 여전히 대다수의 웹사이트 방문객들은 느린 속도에 대해 불만을 가지고 있다.

	웹사이트는 과거 보다 현재 훨씬 많은 정보를 제공하기 때문
    
-   개발자의 기기는 일반적인 사용자의 기기보다 성능이 뛰어나고, 네트워크 환경도 안정적 ->   웬만하면 개발자의 기기에서 성능 문제를 경험하기 어렵


- 과거 웹사이트의 성능 측정 방법 : 단순히 웹사이트의 로딩 속도, 방문이나 결제 같은 실제 목표로 이뤄지는 전환율 등으로만 판단. - 뚜렷한 표준이나 측정 방법이 정해져 있지 않아서 → 일관되게 판단하기 어려웠음

- 요즘 : 구글이 제시한 핵심 웹 지표 사용

#   12.2 핵심 웹 지표란?

: 웹서비스의 성능을 객관적으로 평가할 수 있는 지표
    
-   외국에선 core web vital로 알려짐
    
-   구글에서 만듦
    
-   과거 일관되게 성능 판단하기 어려움을 해결하기 위해 → 구글에서 사이트에서 핵심적인 웹 지표를 몇 가지로 요약하고, 이 지표를 측정할 수 있는 방법을 명확히 제시했다
    
-   **구글에서 꼽는 핵심 웹 지표**
    
    -   LCP
    -   CLS
    
-   핵심까지는 아니지만, 특정 문제를 진단하는 데 사용될 수 있는 지표
    
    -   FCP


#   12.3 LCP

##   12.3.1 정의

-   largest contentful paint
    
-   : 페이지가 처음으로 로드를 시작한 시점부터 사용자의 기기의 뷰포트 내부에서 가장 큰 이미지 또는 텍스트를 렌더링하는 데 걸리는 시간을 측정하는 지표
    
-   뷰포트 내부에서 정의돼 있는 큰 이미지와 텍스트
    
    -   `<img>`
    -   `<svg>` 내부의 `<img>`
    -   poster 속성을 사용하는 `<video>`
    -   url()을 통해 불러온 배경 이미지가 있는 요소
    -   인라인 텍스트 요소를 포함하는 블록 레벨 요소
        이 블록 레벨 요소엔 `<p>`, `<div>` 등이 포함

-   오직 뷰포트 영역만 영향을 미친다.

-   lcp는 페이지 로딩에 따라 변화한다.

	_오 lcp는 계속 바뀌는거야? 난 여태껏 한 페이지에서 lcp는 하나로 고정인줄_
    
-   cf) 뷰포트
    
    -   : 사용자에게 현재 노출되는 화면
        
    -   뷰포트는 기기에 의존하므로, 뷰포트 크기는 기기마다 다르다.
        
        ex) 모바일 기기는 pc에 비해 뷰포트가 작다.
        
        
##   12.3.2 의미

-   cf) DOMContentLoaded
    
    -   : html 문서를 완전히 불러오고 파싱했을 때 발생하는 이벤트
        
    -   페이지의 document를 대상으로 일어나고, 단 한번만 호출된다
        
    -   이 이벤트가 발생했다고 해서 사용자도 페이지가 로딩됐다고 인식할거라고 기대하기는 어렵다. 이유 : 이 DOMContentLoaded 이벤트는 스타일 시트, 이미지 등의 로딩은 기다리지 않기 때문
        
        ex) 만약 뷰포트 영역이 대부분 이미지로 이뤄져있고, 이미지의 크기가 커서 로딩이 오래 걸린다면 브라우저가 DOMContentLoaded 이벤트를 실행했더라도 사용자는 페이지의 로딩이 끝났다고 생각하지 않을 것임.
        
        **DOMContentLoaded로 측정하면 개발자가 예상한 페이지 로딩 시간과 사용자가 체감한 페이지 로딩 시간엔 차이가 있을 것이다.**
        
-   사용자가 페이지가 어느 정도 로딩됐다고 인식하는 시점
    
    -   사용자가 페이지 로딩을 체감하기 위해서 꼭 페이지가 완전히 로딩될 필요는 없다.
        
        ex) document가 1000~2000줄 정도 되는 웹사이트에서 하단 영역은 IntersectionObserver로 구현돼 있어서 아직 뷰포트에 걸치지 않아서 미처 로딩돼 있지 않더라도, 일단 **사용자에게 노출된 부분만 로딩돼있다면 사용자는 페이지 로딩이 완료됐다고 느낄 것**


##   12.3.5 개선 방안

### 텍스트

lcp 예상 영역에 텍스트로 표현할 수 있는 부분은 이미지가 아닌 문자열을 넣기. 이미지를 아무리 최적화해도 이미지는 추가적인 리소스 다운로드가 필요하기 때문에 텍스트 노출이 훨씬 더 빠르다. 

_텍스트를 먼저 띄운 다음에 로드되면 이미지를 띄우라는 말인가? ㄴㄴ 그냥 이미지 ‘대신’ 텍스트 띄우라는 말_

_음.. 뭔가 대증 요법 같아.._

### 이미지는 어떻게 불러올 것인가?

개발자가 텍스트로 lcp를 최적화하려해도, 디자이너, 기획자 그리고 웹 사이트 관련 이해관계자들은 사용자에게 좀 더 강렬한 인상을 주기 위해 텍스트보단 이미지를 사용하길 원할 것이다.

_ㅇㅇ 나도 동의_

**이미지 노출 방법**

-   `<img>`, `<picture>`
    
    `<img>` / `<picture>` 내부의 리소스는 html 파싱이 완료되지 않더라도 프리로드 스캐너가 발견해서 병렬적으로 리소스를 다운로드하므로 -> lcp 요소를 불러오기에 적절한 방법이다. + `<picture>`도 마찬가지
    
    _preload 어디서 봤는디_
    
    -   cf) 프리로드 스캐너 : html을 파싱하는 단계를 차단하지 않고, 이미지와 같이 빠르게 미리 로딩하면 좋은 리소스를 먼저 찾아서 로딩하는 브라우저의 기능

	    _오홍 이런 기능이 있구나_
    
-   `<svg>` 내부의 `<img>`
    
    `<img>`와 다른 점 : 모든 리소스가 다운로드 된 이후에 이미지를 불러온다. 즉, **프리로드 스캐너가 발견하지 않아 병렬적으로 다운로드가 일어나지 않는다**. 이는 lcp 점수에도 악영향을 미치므로 삼가는 것이 좋다
    
-   `<video>`의 poster
    
    -   도 마찬가지로 프리로드 스캐너에 의해 조기에 발견돼서 `<img>`와 같은 성능을 나타낸다.
        
-   `background-image: url()`
    
    background-image를 포함한 css에 있는 리소스는 항상 느리다. 브라우저가 해당 리소스를 필요로 하는 dom을 그릴 준비가 될 때까지 리소스 요청을 뒤로 미루기 때문. — lcp에도 안좋은 영향을 미친다. → **가능하다면 background-image는 lcp와 같이 중요한 리소스에는 사용하지 않는 것이 좋다.**

### 그 밖에 조심해야 할 사항

-   이미지 무손실 압축 - 웹으로 서비스할 이미지는 가능한 무손실 형식으로 압축해서 최소한의 용량으로 서비스하는 것이 좋다.
    
-   클라이언트에서 빌드하지 말기
    
    최적의 시나리오 : 서버에서 빌드해온 html을 프리로드 스캐너가 바로 읽어서 lcp로 빠르게 가져가는 것.

-   최대 콘텐츠풀 리소스는 직접 호스팅
    
    다른 출처(origin)에서 정제한 이미지를 가져오는 것은 최적화에 별로 좋은 영향을 미치지 않는다. 이유 : 연결이 맺어진 현재 출처와는 다르게, 완전히 새로운 출처의 경우엔 네트워크 연결부터 다시 해야하기 때문.
    
	 **가능한 중요한 리소스는 직접 다루고, 그 외에 덜 중요한 리소스에 대해서만 이미지 최적화 서비스를 사용하는 것이 좋다.**

#   12.5 CLS   
 
##   12.5.1 정의

-   cumulative layout shift

-   : 페이지의 생명주기 동안 발생하는 모든 예기치 않은 이동에 대한 지표를 계산하는 것

-   지표가 낮을수록 / 사용자가 겪는 예상치 못한 레이아웃 이동이 적을수록 더 좋은 웹사이트다

- 같은 화면에서 cls를 발생시키는 요소의 크기가 동일해도, 기기의 크기에 따라 점수가 다르게 측정될 수 있다.
	점수가 크든 작든 cls로 인해 불편을 겪는건 둘 다 마찬가지

-   웹사이트에서 예기치 못한 작동을 야기해 사용자가 원래 하려던 동작을 방해하고, 사용자를 불쾌하게 한 사용자 경험 EX
    -   로딩이 끝난 줄 알고 무언가를 클릭하려고 했는데 그 사이에 다른 요소가 로딩되면서 원래 클릭하려고 했던 요소를 클릭하지 못해서 당황
    -   읽고 있던 무언가가 다른 요소의 출력으로 인해 사라짐
    
    *나도 살면서 꽤 겪었으*

##   12.5.2 의미

-   과거 웹사이트 - 제한적인 트래픽과 리소스로 인해 제공하는 정보가 비교적 한정적
    
-   리액트로 만들어진 웹사이트
    
    -   useEffect
        -   렌더링이 한 번 끝난 이후에 콜백 함수를 실행
            
        -   내부에 ui 레이아웃을 변경하는 작업을 하는 useEffect가 많을수록 cls가 좋지 못한 점수를 받을 가능성이 커진다.
            
-   **측정**
    
    -   뷰포트 내부의 요소에 대해서만 측정
        
    -   최초 렌더링이 시작된 위치에서 레이아웃의 이동이 발생하는 경우
        
    -   요소가 추가됐을때 **다른 요소의 시작 위치에 영향을 미치는 경우**
        
    -   사용자가 아무런 동작을 하지 않았음에도 레이아웃 이동이 발생하는 경우
        
-   **점수 계산 시 포함되는 내용**
    
    -   **영향분율** : 레이아웃 이동이 발생한 요소의 전체 높이와 뷰포트 높이의 비율

                
    -   **거리분율** : 레이아웃 이동이 발생한 요소가 뷰포트 대비 얼마나 이동했는지 비율

    위 두 가지 점수롤 곱하면 최종 점수다.

    
    _오 자세한 점수 계산 방법은 처음 공부해봐_

##   12.5.5 개선 방안

### 삽입이 예상되는 요소를 위한 추가적인 공간 확보

cls는

-   대부분 클라이언트에서 동적인 요소를 삽입해서 발생
-   이외에 갑자기 요소의 크기가 바뀌거나, 뒤늦게 광고 같은 타사 라이브러리리가 브라우저에서 로드되는 등의 작업으로 인해 발생

위 영향을 받는 것을 **방지**하기 위해선

-   **useEffect 내부에서 뷰포트 내부에서 노출될 확률이 높은 요소에 영향을 미치는 작업을 최소화**
    -   useEffect 사용이 불가피하다면 UseLayoutEffect를 사용 검토!
    
-   **무언가가 동적으로 뜰 것으로 예상되는 공간을 미리 확보**
    -   ex) 스켈레톤 ui
    -   장점   : 레이아웃 이동을 막고, 클라이언트 시점에 정해지는 콘텐츠를 안정적으로 보여줄 수 있음 → 대부분의 경우 추천하는 방법

-   가장 좋은 방법 : **ssr**
    -   서버에서 클라이언트에게 html을 제공한다면 클라이언트에선 이러한 고민을 할 필요가 없음!


**최초 뷰포트 영역은 사용자에게 첫 번째로 이 웹서비스에 대한 인상을 주는 가장 중요한 영역**이므로 → 동적인 콘텐츠를 제공할지 신중하게 고민해야한다. **동적인 콘텐츠는 가능한 최초 뷰포트에 영향을 미치지 않는 곳에서 사용**하고, 불가피하다면 위 방법들을 사용해서 **최대한 레이아웃 이동을 피해야한다.**

### 폰트 로딩 최적화

-   폰트도 레이아웃 이동을 일으키는 원인 중 하나다.
    
-   폰트로 인해 발생할 수 있는 문제 2개
    
    -   FOUT 
    -   FOIT
    
-   폰트는 각각 고유의 높이와 너비를 가진다. 즉, 지정한 폰트가 다운로드되기 전에 텍스트를 노출할때, 크기가 다른 기본 폰트가 적용된 텍스트를 노출하거나 텍스트를 노출하지 못해서 cls가 발생할 수 있다. 따라서 사용자 기기의 기본 폰트 이외에 다른 폰트로 보여주고 싶으면 아래와 같은 점을 유념하기
    
    -   `<link>`의 `rel=preload` 사용
        -   페이지에서 즉시 필요로 하는 리소스를 명시
        -   preload로 지정된 요소는 웹페이지의 생명주기에서 초기에 불러와야 하는 중요한 리소스로 간주되므로 → 브라우저는 리소스를 더 빠르게 사용할 수 있도록 준비한다
        -   preload로 폰트를 지정하면 → 페이지의 레이아웃을 방해할 가능성이 줄어든다.
    -   `font-family: optional` 사용

   **중요한 폰트의 다운로드를 최대한 우선순위에서 높게 잡고, 그럼에도 빠르게 로딩하는데 실패했다면 → 기본 폰트를 노출 시키기**. ⇒ 사용자가 예기치 못하게 변경된 폰트로 혼선을 겪는 것을 방지한다.
    

### 적절한 이미지 크기 설정
    
-   ex) img css 설정
    
    -   width : 100% - 기기의 너비대로
        
    -   height : auto
        
        -   높이가 너비에 자동으로 비례
        -   반응형 웹사이트에 최적화할 수 있는 기법임. 기기의 너비가 어떻게 되든 원본 이미지의 가로세로 비율이 일정해서 → 사용자에게 최적의 이미지를 보여줄 수 있음
        
    -   문제 : cls 발생
        
        원인 : 위 css 설정 때문. - 이미지가 완전히 다운로드되기 전까지 **높이를 알 수 없기 때문에** → 이미지의 높이를 높게 잡아뒀다가 → 이미지가 완전히 로딩 완료된 이후 → 기기의 너비만큼 높이 계산해서 자리 잡음
        
    -   문제 해결 방법
        
        -   **width, height 지정**
            
            -   가장 좋은 방법
                
            -   width: 100%; height : auto;에다 + width, height를 원하는 **비율**로 지정하면 → 브라우저가 이미지를 로딩하기 전에 적절한 가로세로 비율을 계산해서 → 이미지가 표시되는 만큼 면적을 할당해둔다. 이는 aspect-ratio 덕분 ⇒ 이미지 로딩으로 인해 예기치 못하게 레이아웃 이동하는 것을 막을 수 있다.

            
            _관련 코드 작성할때 이미지의 width, height 지정안해도 그걸 감싸는 div 같은 wrapper가 있으면 이미지 크기가 변경되고 이러지 않았던것같은데. 이런 경우에도 width, height 지정해주는게 좋을까?_
            
        -   srcset 속성 - 사용자 뷰포트 너비에 맞춰 다른 이미지를 제공하고 싶은 경우

    
##   12.5.6 핵심 웹 지표는 아니지만 성능 확인에 중요한 지표들

### FCP

first contentful paint

-   페이지가 로드되기 시작한 시점 ~ 페이지 콘텐츠의 일부(텍스트, 이미지, svg 등)가 화면에 렌더링될 때까지의 시간을 측정

-   개선 시 고려 사항
        
    -   **렌더링을 방해하는 리소스 최소화**
        
        자스나 css 같은 리소스를
        
        -   최소화
        -   비동기적으로 로드
        
    -   **above the fold**
        
        -   신문에서 비롯된 용어
        -   신문 - 일반적으로 신문이 독자에게 제공될때 첫 번째 페이지가 반으로 접혀서 보여지는데, 이렇게 접혀서 가장 먼저 보이는 영역.
        -   웹 - 최초에 스크롤을 안해도 보이는 영역
        -   이 영역은 사용자에게 최대한 빠르게 무언가를 보여줘야 하는 영역임 → lazy loading을 하거나 스크립트에 의존(ex. useEffect)해 요소가 렌더링되는 것을 피해야된다. 
        lazy loading이나 스크립트에 의존하는 것은 fcp에 도움 되지 않는다!
        
        _오 이런 용어 재밌어ㅜ_
        
        _헐 lazy loading 관련해서 너무나 필요했고 좋은 표현 발견~!_
        
    -   **페이지 리다이렉트 최소화**
        
        리다이렉트 하면 그만큼 사용자에게 무언가를 보여줄 수 있는 시간이 지연되기 때문
        
    -   **dom 크기 최소화**
        
        -   html의 크기가 크다면 → 그만큼 렌더링되는 데 시간이 오래 걸림
            
        -   구글 기준 : 전체 dom 노드는 1500개 미만, 깊이는 32단계 정도까지, 부모 노드는 자식 노드를 60개 정도만 가지고 있어야 함
            
            이 이상으로 dom이 크고 복잡하면 → 브라우저가 이를 파악하고 렌더링하는 데 시간이 오래 걸린다.
            
        
        웹페이지를 소스 보기로 확인해보고 dom을 줄일 수 있는 방법을 고민해보면 좋다.
        
#   12.6 정리

일반적으로 웹페이지를 개발하다 보면 기능을 얼마나 완성했는지, 버그는 얼마나 적은지 위주로 생각하기 때문에 성능에 대해서는 깊게 고민해 볼 시간이 많이 부족하다.

_인정_

그럼에도 개발자는 성능 또한 완성도만큼이나 중요하게 살펴봐야 한다. 웹페이지에서 아무리 좋은 콘텐츠가 제공되고 있다 하더라도 사용자의 환경은 생각보다 성능이 열악하고, 속도는 느리고, 인내심도 많지않다.

0.1~0.2초 차이만으로도 사용자에게 큰 차이를 느끼게 해줄 수 있다. 지표 한두 가지를 개선했다 하더라도 체감될 만큼 큰 차이가 없을 수도 있다. 하지만 이런 개선점이 모이다 보면 분명히 더 나은 서비스를 만들 수 있다.

*동의합니다*
