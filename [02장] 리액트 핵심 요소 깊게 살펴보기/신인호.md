# 2장 리액트 핵심 요소 깊게 살펴보기

## 2.1 JSX란?

JSX는 페이스북이 임의로 만든 새로운 문법이다. 때문에 반드시 트랜스파일러를 거쳐야 자바스크립트 코드로 변환된다.

### 2.1.1 JSX 정의

기본적으로 JSXElement, JSXAttributes, JSXChildren, JSXStrings라는 4가지 컴포넌트를 기반으로 구성돼 있다.

- JSXElement
  - JSXOpeningElement: `<div>`
  - JSXClosingElement: `</div>`
  - JSXSelfClosingElement: `<br />`
  - JSXFragment: `<></>`

> 요소명은 대문자로 시작해야 하나요?
>
> 대문자로 시작하면 리액트 컴포넌트로 인식하고, 소문자로 시작하면 HTML 태그로 인식한다.

- JSXElementName: JSXElement의 이름을 나타내는 컴포넌트

  - JSXIdentifier: 내부에서 사용하는 식별자 `$`, `_` 로 시작할 수 있음. `<$></$>`
  - JSXNamespacedName: `namespace:name`, 두개의 식별자로 이루어짐. 그 이상은 불가능.
  - JSXMemberExpression: `props.name`, `:` 과 다르게 `.`을 여러 개 이어서 쓸 수 있음.

- JSXAttributes

  - JSXAttribute: name="value"
  - JSXSpreadAttribute: {...props} 전개 연산자와 동일한 역할

- JSXChildren

  - JSXChild: JSXChildren을 이루는 기본 단위. 0개 이상의 JSXChild가 존재할 수 있음.

    - JSXText: 문자열
    - JSXElemnet: 값으로 다른 JSX 요소가 들어갈 수 있음
    - JSXFragment: 빈 요소가 들어갈 수 있음
    - { JSXChildExpression (optional) }:

    ```jsx
    export default function App() {
      return <>{(() => "foo")()}</>;
    }
    ```

- JSXStrings: HTML에서 사용 가능한 문자열은 모두 사용 가능. `\`를 사용할 때만 `\\`로 작성해야 하는 것을 주의하자.

### 2.1.2 JSX 예제

```jsx
const ComponentA = () => <A {...{ required: true }} />;
const ComponentB = () => <A required={true} />;
const ComponentC = () => <A optionalChildren={<>안녕하세요</>} />;
```

```jsx
function ComponentA() { return <A.B></A.B> }
function ComponentB() { return <A.B.C></A.B.C> }
function ComponentC() { return <A:B.C></A:B.C> }
function ComponentD() { return <$></$> }
function ComponentE() { return <_></_> }
```

### 2.1.3 JSX는 어떻게 자바스크립트에서 변환될까?

```jsx
const ComponentA = () => <A {...{ required: true }}>Hello, world!</A>;
const ComponentB = () => <>Hello, world!</>;
```

@babel/plugin-tranform-react-jsx로 변환한 결과

```jsx
"use strict";
const ComponentA = React.createElement(A, { required: true }, "Hello, world!");
const ComponentB = React.createElement(React.Fragment, null, "Hello, world!");
```

리액트17, 바벨 7.9.0 이후 버전에서 추가된 자동 런타임으로 @babel/plugin-transform-react-jsx로 변환한 결과

```jsx
"use strict";

var _jsxRuntime = require("custom-jsx-runtime/jsx-runtime");
const ComponentA = (0, _jsxRuntime.jsx)(A, {
  required: true,
  children: "Hello, world!",
});
const ComponentB = (0, _jsxRuntime.jsx)(_jsxRuntime.Fragment, {
  children: "Hello, world!",
});
```

JSX가 변환되는 특성을 활용한다면 다음과 같이 코드 중복 없이 간결하게 처리할 수 있다.

```jsx
import { createElement } from "react";

function TextOrHeading({
  isHeading,
  children,
}): PropsWithChildren<{ isHeading: boolean }> {
  return createElement(
    isHeading ? "h1" : "span",
    { className: "text" },
    children
  );
}
```

### 2.1.4 정리

리액트에서 사용하지 않는 JSX 문법

- JSXNamespacedName
- JSXMemberExpression

## 2.2 가상 DOM과 리액트 파이버

### 2.2.1 DOM과 브라우저 렌더링 과정

1. 브라우저가 사용자가 요청한 주소를 방문해 HTML 파일을 다운로드한다.
2. 브라우저의 렌더링 엔진은 HTML을 파싱해 DOM 노드로 구성된 트리(DOM)를 만든다.
3. 2번 과정에서 CSS 파일을 만나면 해당 CSS 파일도 다운로드한다.
4. 브라우저의 렌더링 엔진은 이 CSS도 파싱해 CSS 노드로 구성된 트리(CSSOM)를 만든다.
5. 브라우저는 2번에서 만든 DOM 노드를 순회하는데, 여기서 모든 노드를 방문하는 것은 아니고 사용자 눈에 보이는 노드만 방문한다. 즉, display: none과 같이 사용자 화면에 보이지 않는 요소는 방문해 작업하지 않는다. 이는 트리를 분석하는 과정을 조금이라도 빠르게 하기 위해서다.
6. 5번에서 제외된, 눈에 보이는 노드를 대상으로 해당 노드에 대한 CSSOM 정보를 찾고 여기서 발견한 CSS 스타일 정보를 이 노드에 적용한다. 이 DOM 노드에 CSS를 적용하는 과정은 크게 두 가지로 나눌 수 있다.

- 레이아웃(layout, reflow): 각 노드가 브라우저 화면의 어느 좌표에 정확히 나타나야 하는지 계산하는 과정. 이 레이아웃 과정을 거치면 반드시 페인팅 과정도 거치게 된다.
- 페인팅(painting): 레이아웃 단계를 거친 노드에 색과 같은 실제 유효한 모습을 그리는 과정.

### 2.2.2 가상 DOM의 탄생 배경

레이아웃과 페인팅 과정은 매우 비싼 작업이다. 때문에 이 과정을 최소화하는 것이 중요하다.

SPA에서 더 많은 렌더링 과정이 일어난다. 일반적인 웹페이지와는 다르게 하나의 페이지에서 계속해서 요소의 위치를 재계산하게된다. 사용자는 페이지의 깜빡임 없이 자연스러운 웹페이지 탐색을 할 수 있지만 그만큼 DOM을 관리하는 과정에서 비용이 커진다.

DOM의 최종 결과물을 간편하게 알기 위해 가상 DOM이 등장했다. 가상 DOM은 일단 메모리에 저장하고 실제 변경에 대한 준비가 완료됐을 때 실제 브라우저의 DOM에 반영한다.

### 2.2.3 가상 DOM을 위한 아케텍처, 리액트 파이버

가상 DOM과 렌더링 과정 최적화를 가능하게 해주는 것이 리액트 파이버다.

리액트를 관리하는 평범한 자바스크립트 객체다. 파이버는 파이버 재조정자(fiber reconciler)가 관리하며, 가상 DOM과 실제 DOM을 비교해 렌더링을 요청하는 역할을 한다. 모든 과정은 비동기로 처리된다.

파이버는 하나의 작업 단위로 구성되어 있고, 작업을 하나씩 처리하고 finishedWork()라는 작업으로 마무리한다.

1. 렌더 단계에서 리액트는 비동기 작업을 수행한다. 파이버의 작업, 우선순위를 지정하거나 중지시키거나 버리는 등의 작업이 일어남
2. 커밋 단계에서는 앞서 언급한 것처럼 DOM에 실제 변경 사항을 반영하기 위한 작업, commitWork()가 실행되는데, 이 과정은 앞서와 다르게 동기식으로 일어나고 중단될 수도 없다.

파이버는 createFiberFromElement() 함수를 통해 유추할 수 있는게 하나의 element에 1:1 관계를 가지고 있다.
그 매칭 정보를 가지고 있는게 tag 속성이다.

중요한 것은 리액트가 파이버를 처리할 때마다 작업을 직접 바로 처리하기도 하고 스케줄링하기도 한다는 것이다. 즉, 작업들을 작은 단위로 나눠서 처리할 수도, 애니메이션과 같이 우선순위가 높은 작업은 가능한 한 빠르게 처리하거나, 낮은 작업을 연기시키는 등 좀 더 유연하게 처리한다.

가상 DOM이 생각보다 단순한 자바스크립트 객체로 관리되고, 리액트 개발 팀 왈 리액트는 가상 DOM이 아닌 Value UI, 즉 값을 가진 UI를 관리하는 라이브러리라고 한다.

#### 리액트 파이버 트리

파이버 트리는 리액트 내부에서 두 개가 존재한다. 하나는 현재 모습의 파이버 트리, 다른 하나는 작업 중인 상태의 workInProgress 트리다.

리액트 파이버의 작업이 끝나면 리액트는 포인터를 변경해 workInProgress 트리를 현재 트리로 바꾼다. 이를 **더블 버퍼링**이라고 한다.

#### 리액트 파이버 작업 순서

1. beginWork(): 더 이상 자식이 없는 파이버를 만날 때까지 트리 형식으로 시작된다.
2. 1번 작업이 끝나면 completeWork()를 실행해 파이버 작업을 완료한다.
3. 형제가 있다면 형제로 넘어간다.
4. 2번, 3번이 모두 끝나면 return으로 돌아가 자신의 작업이 완료됐음을 알린다.

이렇게 트리를 완성하고, 업데이트가 되면 기존 파이버에서 업데이트된 props를 받아 파이버 내부에서 처리한다.

### 2.2.4 파이버와 가상 DOM

리액트 컴포넌트에 대한 정보를 1:1로 가지고 있는 것이 파이버이며, 리액트 아키텍처 내부에서 비동기로 이루어짐.

실제 DOM에 반영하는 것은 동기적으로 일어나야 하고, 처리하는 작업이 많아 화면이 불완전하게 표시될 가능성이 있어서 메모리에서 먼저 수행 후, 최종 결과물만 실제 브라우저 DOM에 반영한다.

### 2.2.5 정리

가상 DOM을 구현하기 위해 리액트 파이버가 등장했다. 가상 DOM과 리액트의 핵심은 브라우저의 DOM을 더욱 빠르게 그리고 반영하는 것이 아니라 값으로 UI를 표현하는 것이다. 화면에 표시되는 UI를 자바스크립트의 문자열, 배열 등과 마찬가지로 값으로 관리하고 이러한 흐름을 효율적으로 관리하기 위한 메커니즘이 바로 리액트의 핵심이다.

## 2.3 클래스 컴포넌트와 함수 컴포넌트

리액트 버전 0.14에 함수 컴포넌트가 등장했다. 이 때는 무상태 함수 컴포넌트로 사용되어 정적으로 렌더링하는 것이 목적이었다.

함수 컴포넌트가 각광받은 것은 16.8 버전에서 추가된 Hooks 덕분이다. 훅이 등장한 이후 상태나 생명주기 메서드 비슷한 작업을 흉내 낼 수 있게 되었고, 상대적으로 보일러 플레이트가 복잡한 클래스 컴포넌트보다 함수 컴포넌트를 많이 쓰게 되었다.

### 2.3.1 클래스 컴포넌트

기본적으로 클래스 컴포넌트는 클래스를 선언하고 extends로 상속받아 사용한다.

- React.Component: 클래스 컴포넌트의 기본 클래스
- React.PureComponent: 얕은 비교를 통해 렌더링 최적화를 돕는 클래스

```jsx
class App extends React.Component {
  render() {
    return <div>Hello, world!</div>;
  }
}
```

- constructor(): 초기화 시점에 호출.
- super()는 상속받은 상위 컴포넌트인 React.Component의 생성자를 호출해 필요한 상위 컴포넌트에 접근할 수 있게 도와준다.
- render(): 렌더링 시점에 호출. 렌더링 결과물을 반환한다.

#### 클래스 컴포넌트의 생명주기 메서드

생명주기 메서드가 실행되는 시점은 크게 3가지이다.

- 마운트(mount): 컴포넌트가 처음 생성되는 시점
- 업데이트(update): 이미 생성된 컴포넌트의 내용이 변경되는 시점
- 언마운트(unmount): 컴포넌트가 더 이상 존재하지 않는 시점

#### render()

- 리액트 클래스 컴포넌트의 유일한 필수 값. UI 렌더링에 쓰인다.
- 항상 순수해야 하며 부수 효과가 없어야 한다. 즉, props, state가 같은 입력 값이면 항상 같은 결과를 반환해야 한다. 따라서 render() 내부에서 state를 직접 업데이트하는 this.setState를 호출해서는 안 된다.

#### componentDidMount()

- 컴포넌트가 마운트되고 준비되는 즉시 실행된다.
- render()와 다르게 this.setState()로 state값을 변경하는 것이 가능하다.
- this.setState()을 호출했다면 그 즉시 다시 한번 렌더링을 시도하는데, 이 작업은 브라우저가 실제로 UI를 업데이트하기 전에 일어난다.
- 보통 API 호출 후 업데이트, DOM에 의존적인 작업(이벤트 리스너 등)을 하기 위해서 쓴다.

#### componentDidUpdate()

- 컴포넌트가 업데이트되고 나서 실행된다.
- 적절한 조건문을 쓰지 못하면 계속 실행될 수 있다.

#### componentWillUnmount()

- 컴포넌트가 언마운트되기 전에 실행된다.
- 메모리 누수나 불필요한 작동을 막기 위한 클린업 함수를 호출하기 위한 최적의 위치다.
- this.setState를 호출할 수 없다.

#### shouldComponentUpdate()

- state나 props의 변경으로 다시 리렌더링되는 것을 막고 싶다면 이 생명주기 메서드를 사용하면 된다.

#### static getDerivedStateFromProps()

- render()를 호출하기 전에 호출되는 메서드. 사라진 componentWillReceiveProps() 메서드를 대체한다.
- static으로 선언돼 this에 접근할 수 없다.
- 주로 props에 기반해 state를 업데이트하는 용도로 사용된다.

#### getSnapshotBeforeUpdate()

- DOM 업데이트되기 직전에 호출되는 메서드. 사라진 componentWillUpdate() 메서드를 대체한다.
- 여기서 반환되는 값은 componentDidUpdate()에서 세 번째 파라미터인 snapshot으로 전달된다.
- 렌더링 전 윈도우 크기 조절이나 스크롤 위치 조정 등의 작업 처리에 유용하다.

#### getDerivedStateFromError()

- 자식 컴포넌트에서 에러가 발생했을 때 호출되는 에러 메서드.
- error를 인수로 받는다.
- render 단계에서 실행된다.

#### componentDidCatch()

- 자식 컴포넌트에서 에러가 발생했을 때 실행되며, getDerivedStateFromError에서 에러를 잡고 state를 결정한 이후에 실행된다.
- 두 개의 인수를 받고, 첫번째는 error, 두번째는 info이다.
- commit 단계에서 실행된다.

#### 클래스 컴포넌트의 한계

- 데이터 추적이 어렵다. (state 흐름을 추적하기 매우 어렵다.)
- 애플리케이션 내부 로직의 재사용이 어렵다. (공통 로직을 재사용하기 어렵다.)
- 기능이 많아질수록 컴포넌트의 크기가 커진다.
- 클래스는 함수에 비해 상대적으로 어렵다.
- 코드 크기를 최적화하기 어렵다. (함수 컴포넌트에 비해 번들링을 최적화 하기 어렵다.)
- 핫 리로딩이 어렵다. (핫 리로딩: 코드를 변경하고 저장하면 변경 사항이 실시간으로 적용되는 것)

### 2.3.2 함수 컴포넌트

16.8에서 훅이 등장하면서 함수 컴포넌트의 시대가 열렸다.

클래스 컴포넌트에 비해 간결하다.

- this를 사용하지 않는다.
- state는 객체가 아닌 각각의 원시값으로 관리되어 사용하기 편하다.

### 2.3.3 함수 컴포넌트 vs. 클래스 컴포넌트

#### 생명주기 메서드의 부재

개발자들이 적응하지 못하는 부분 중 가장 큰 것은 생명주기 메서드의 부재다. useEffect로 componentDidMount, componentDidUpdate, componentWillUnmount를 비슷하게 구현할 수 있지만 똑같지는 않다.

#### 함수 컴포넌트와 렌더링된 값

클래스 컴포넌트는 props 값을 항상 this로부터 가져온다. this는 컴포넌트 인스턴스의 멤버이기 때문에 변경 가능한 값이다. 렌더 도중 props 값이 변경되면 렌더링 결과물이 달라질 수 있다. 하지만 함수 컴포넌트는 렌더링이 일어날 때마다 그 순간의 값인 props와 state 값으로 렌더링 된다.

#### 클래스 컴포넌트를 공부해야 할까?

래액트의 오랜 역사 동안 많은 코드들이 클래스 컴포넌트로 작성됐으며 이러한 흐름을 알기 위해서는 어느 정도 클래스 컴포넌트를 이해하는 것이 좋다. 특ㅎ히 자식 컴포넌트에서 발생한 에러에 대한 처리는 현재 클래스 컴포넌트로만 가능하므로 에러 처리를 위해서라도 클래스 컴포넌트에 대한 지식은 어느 정도 필요하다고 볼 수 있다.

### 2.3.4 정리

함수 컴포넌트를 먼저 사용해보고 클래스 컴포넌트까지 익혀본다면 리액트를 더 잘 이해할 수 있을 것이다.

## 2.4 렌더링은 어떻게 일어나는가?

리액트도 브라우저처럼 자체적인 렌더링 프로세스가 있다.

### 2.4.1 리액트의 렌더링이란?

리액트 렌더링이란 리액트 애플리케이션 트리 안에 있는 모든 컴포넌트들이 현재 자신들이 가지고 있는 props와 state의 값을 기반으로 어떻게 UI를 구성하고 이를 바탕으로 어떤 DOM 결과를 브라우저에 제공할 것인지 계산하는 일련의 과정이다.

### 2.4.2 리액트의 렌더링이 일어나는 이유

리액트 렌더링이 일어나는 이유는 두 가지가 있다.

1. 최초 렌더링: 컴포넌트가 처음 마운트될 때
2. 리렌더링:

- 클래스 컴포넌트: **setState**, **forceUpdate** 등의 함수를 호출해 값이 변경되었을 때
- 함수 컴포넌트: **useState()**의 setter가 실행되는 경우, **useReducer()**의 dispatch가 실행되는 경우
- 컴포넌트의 **key** props가 변경되는 경우:
  key는 리렌더링이 발생하는 동안 형제 요소들 사이에서 동일한 요소를 식별하는 값이다. current 트리와 workInProgress 트리에서 동일한 컴포넌트를 구별하는 값이 key다.
- **props** 가 변경되는 경우
- **부모 컴포넌트가 리렌더링** 되는 경우: 부모 컴포넌트가 리렌더링되면 자식 컴포넌트도 무조건 리렌더링된다.

### 2.4.3 리액트의 렌더링 프로세스

- 컴포넌트의 루트에서부터 시작해 모든 자식 컴포넌트까지 렌더링 작업을 수행한다.
- 내려가면서 업데이트가 필요하다고 지정돼 있는 모든 컴포넌트를 찾는다.
- render() 또는 FunctionComponent()를 호출해 렌더링 결과물을 저장한다.
- 렌더링 결과물을 바탕으로 실제 DOM에 적용할 모든 변경 사항을 수집한다.
- 수집한 모든 변경 사항을 하나의 동기 시퀀스로 실제 DOM에 적용한다.

### 2.4.4 렌더와 커밋

렌더링 과정은 두 단계로 나뉜다.

1. 렌더링 단계: 컴포넌트를 렌더링하고 변경 사항을 계산하는 단계(type, props, key를 비교)
2. 커밋 단계: 렌더링 결과물을 실제 DOM에 적용하는 단계

리액트가 DOM을 커밋 단계에서 업데이트한다면 이렇게 만들어진 모든 DOM 노드 및 인스턴스를 가리키도록 리액트 내부의 참조를 업데이트 한다.
그 다음, 생명주기 componentDidMount, componentDidUpdate 메서드를 호출한다. 함수 컴포넌트에서는 useLayoutEffect 훅을 호출한다.

"중요한 사실은 **리액트의 렌더링이 일어난다고 해서 무조건 DOM 업데이트가 일어나는 것은 아니라는 것이다.**"

렌더링을 했어도 커밋 단계까지 갈 필요가 없다면, 이 커밋 단계는 생략될 수 있다.

렌더링은 항상 동기식으로 작동한다. 렌더링 과정이 길수록 성능 저하로 이어지고, 브러우저의 지연으로 이어질 수 있다.

의도된 우선순위로 컴포넌트를 렌더링해 최적화할 수 있는 비동기 렌더링 방법, 동시성 렌더링이 18에 등장했다.

### 2.4.5 일반적인 렌더링 시나리오 살펴보기

컴포넌트를 렌더링하는 작업은 별로도 렌더링을 피하기 위한 조치가 돼 있지 않는 한 하위 모든 컴포넌트에 영향을 미친다. 그리고 부모가 변경됐다면 props가 변경됐는지와 무관하게 자식 컴포넌트도 리렌더링 된다.

memo() 함수는 컴포넌트를 메모이제이션해 렌더링을 방지할 수 있다.

```jsx
const D = memo(() => {
  return <>리렌더링 되지 않아요</>;
});
```

정확히는 렌더 단계에서 컴포넌트 비교를 거쳤지만 memo로 선언한 덕분에 props가 변경되지 않으면 렌더링이 생략되므로 커밋 단계도 생략된 것이다.

### 2.4.6 정리

리액트의 리렌더링 과정을 개발자 스스로가 주의 깊게 살펴보지 않았다면 꽤나 자주 렌더링이 일어난다는 사실을 눈치채지 못했을 것이다.
리액트에서 일어나는 렌더링 시나리오를 정확히 이해한다면 컴포넌트의 트리 구조를 개선하거나 불필요한 렌더링 횟수를 줄이는 데 도움이 된다.
성능 좋은 리액트 웹 애플리케이션을 만들기 위해서는 렌더링 과정을 이해하는 것이 중요하다.
