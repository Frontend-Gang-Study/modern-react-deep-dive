# 4. 서버 사이드 렌더링

## 4.1 서버 사이드 렌더링이란?

### 4.1.1 싱글 페이지 애플리케이션의 세상

#### 싱글 페이지 애플리케이션이란?

- body 내부의 내용을 JS 코드로 삽입한 후 렌더링하는 방식

#### 전통적인 방식의 애플리케이션과 싱글 페이지 애플리케이션의 작동 비교

전통적인 방식은 페이지 전환이 발생할 때마다 새롭게 페이지를 요청하고, HTML 페이지를 다운로드해 파싱하는 작업을 거친다.

페이지 전환 시, 브라우저는 새로운 페이지를 요청하고, 서버는 새로운 HTML 페이지를 반환한다. 이 과정에서 페이지가 렌더링되기 전까지 빈 페이지가 보이는 시간이 발생한다.

싱글 페이지 애플리케이션은 페이지 전환이 발생할 때마다 새로운 페이지를 요청하지 않는다. 한번 모든 리소스를 다운로드하고 나면 페이지 전환 시 추가로 리소스를 다운로드할 필요가 없어진다. 훨씬 더 매끄러운 UI를 보여줄 수 있다.

예: Gmail

#### 싱글 페이지 렌더링 방식의 유행과 JAM 스택의 등장

PHP, JSP 기반으로 만들어진 웹 애플리케이션은 서버 사이드 렌더링을 사용한다.

이후, 자바스크립트에서 등장한 CommonJS, AMD(Asynchronous Module Definition) 등의 모듈 시스템 등장과 기기 성능 향상, 인터넷 속도 발전 등으로 자바스크립트에서 할 수 있는 일이 다양해짐.

2010년대 Backbone.js, Knockout.js, AngularJS 등이 등장하면서 MVx 프레임워크를 구현하기 시작했다.

> MVx 프레임워크: Model, View, Controller, x는 프레임워크에 따라 다르다.

- Backbone.js: Model, View, Router
- Knockout.js: Observable, Computed, Subscription
- AngularJS: Model, View, Controller

이후 React, Vue, Svelte 등의 프론트엔드 프레임워크가 등장하면서 싱글 페이지 애플리케이션이 더욱 더 빠르게 발전하기 시작했다.

LAMP 스택: Linux, Apache, MySQL, PHP/Python 등

JAM 스택: JavaScript, API, Markup

Node.js의 고도화에 힘입어 MEAN(MongoDB, Express, Node.js, Angular)이나 MERN(MongoDB, Express, React, Node.js) 스택처럼 아예 API 서버 자체도 자바스크립트로 구현하는 구조가 인기를 끌기 시작했다.

#### 새로운 패러다임의 웹서비스를 향한 요구

2011-2022년 사이 평균 자바스크립트 코드의 크기가 모바일 기준 50KB-> 470KB로 약 9배 증가했다. 웹은 약 100배 증가했다.

하지만, 자바스크립트 파싱을 위해 CPU 사용량이 많이 증가했다.

**중요한 사실은 사용자 기기와 인터넷 속도 등 환경이 크게 개선되었음에도 불구하고 실제 사용자들이 느끼는 로딩 속도는 크게 개선되지 않았다는 것이다.**

### 4.1.2 서버 사이드 렌더링이란?

멀티 페이지 애플리케이션은 모든 페이지를 서버에서 요청받은 후에 완성된 HTML을 렌더링한다.

서버 사이드 방식은 렌더링에 필요한 작업을 모두 서버에서 수행한다.

클라이언트에서 렌더링을 하면 사용자 기기의 성능에 영향을 받지만 서버 사이드 렌더링은 서버에서 제공하기 때문에 비교적 안정적인 렌더링이 가능하다.

#### 서버 사이드 렌더링의 장점

- 최초 페이지 진입이 비교적 빠르다.
  - FCP(First Contentful Paint): 최초 콘텐츠 렌더링 시간
  - 최초 페이지 진입 시 HTML을 받아서 렌더링하기 때문에 빠르다.
- 검색 엔진과 SNS 공유 등 메타데이터 제공이 쉽다.
  - 1. 검색 엔진 로봇이 페이지 진입
  - 2. 페이지가 HTML 정보를 제공해 로봇이 이 HTML을 다운로드한다. 단, 다운로드만 하고 자바스크립트 코드는 실행하지 않는다.
  - 3. 다운로드한 HTML 페이지 내부의 오픈 그래프나 메타 태그 정보를 기반으로 페이지의 검색 정보를 가져오고 이를 바탕으로 검색 엔진에 저장한다.
- 누적 레이아웃 이동이 적다.
  - 누적 레이아웃 이동(Cumulative Layout Shift)는 페이지 로딩 중 레이아웃이 변경되는 것을 의미한다.
  - 페이지를 보여준 후 뒤늦게 어떤 HTML 정보가 추가 삭제되어 화면이 덜컥거리는 것과 같은 부정적인 사용자 경험을 말한다.
- 사용자의 디바이스 성능에 비교적 자유롭다.
- 보안에 좀 더 안전하다
  - 인증 혹은 민감한 작업을 서버에서 수행하고 그 결과만 제공하면 보안 위협을 피할 수 있다.

#### 단점

- 소스코드를 작성할 때 항상 서버를 고려해야 한다.
  - 브라우저 전역 객체인 window, sessionStorage와 같이 브라우저에만 있는 전역 객체의 사용을 피해야 한다. 사용이 불가피하다면 해당 코드가 서버 사이드에서 실행되지 않도록 처리해야 한다.
- 적절한 서버가 구축돼 있어야 한다.
  - SPA나 정적 페이지는 단순히 HTML, JS, CSS 파일을 다운로드할 수 있는 준비만 하면 된다. 하지만 SSR은 서버를 구축해야한다. 사용자 요청에 따라 적절하게 대응할 수 있는 물리적인 가용량을 확보해야 하고, 예기치 않은 장애 상황에 대응할 수 있도록 복구 전략도 필요하다. 또한, 요청을 분산시키고, 프로세스가 예기치 못하게 다운될 때를 대비해 PM2와 같은 프로세스 매니저의 도움도 필요하다.
- 서비스 지연에 따른 문제
  - SPA에서는 느린 작업 시 '로딩 중'과 같이 사용자가 느낄 수 있는 메시지를 제공할 수 있지만, SSR에서는 사용자에게 보여줄 페이지에 대한 렌더링 작업이 끝나기까지는 사용자에게 어떤 정보도 제공할 수 없다.
  - 병목 현상이 심해진다면 때로는 서버 사이드 렌더링이 더 안 좋은 사용자 경험을 제공할 수 있다.

### 4.1.3 SPA와 SSR을 모두 알아야 하는 이유

#### 서버 사이드 렌더링 역시 만능이 아니다

- 웹페이지의 설계와 목적, 우선순위에 따라 SPA이 더 효율적일 수 있다.

#### 싱글 페이지 애플리케이션과 서버 사이드 렌더링 애플리케이션

- 가장 뛰어난 SPA는 가장 뛰어난 멀티 페이지 애플리케이션보다 낫다. (Gmail) lazy로딩과 코드 분할(필요한 코드만 나눠서 번들링하는 기법)을 이용해 빠른 렌더링을 구현할 수 있다.
- 평균적인 노력을 기울여서 동일한 서비스를 만든다면 멀티 페이지 애플리케이션이 더 우위에 있을 수 있다.
  - 멀티 페이지 애플리케이션을 위한 브라우저 API
    - 페인트 홀딩: 같은 출처에서 라우팅이 일어날 경우 화면을 잠깐 하얗게 띄우는 대신 이전 페이지의 모습을 잠깐 보여주는 기법
    - back forward cache(bfcache): 브라우저 뒤로 가기, 앞으로 가기 실행 시 캐시된 페이지를 보여주는 기법
    - Shared Element Transitions: 페이지 라우팅이 일어났을 때 두 페이지에 동일 요소가 있다면 해당 콘텍스트를 유지해 부드럽게 전환되게 하는 기법

#### 현대의 서버사이드 렌더링

요즘 서버 사이드 렌더링 방식으로 서버에서 완성된 HTML을 제공받고, 이후 라우팅에서는 서버에서 내려받은 자바스크립트를 바탕으로 마칭 SPA처럼 렌더링하는 방식이 인기를 끌고 있다. Next.js, Remix, Nuxt.js 등이 이 방식을 사용한다.
