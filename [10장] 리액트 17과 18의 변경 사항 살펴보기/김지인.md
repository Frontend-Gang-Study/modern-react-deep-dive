##   10.2.5 더욱 엄격해진 엄격 모드

### 리액트의 엄격 모드
-   리액트에서 제공
    
-   컴포넌트
    
-   리액트 애플리케이션에서 발생할 수도 있는 잠재적인 버그를 찾는데 도움이 됨
    
-   개발자 모드에서만 작동 ⭕️, 프로덕션 모드에선 작동 ❌
    
-   컴포넌트 형태로 사용 가능 → 리액트 애플리케이션 전체에서 / 특정 컴포넌트 내부에서만 작동하게 할 수 있다
    
    ```jsx
    // 까비 코드
    ReactDOM.createRoot(document.getElementById("root") as HTMLElement).render(
      <React.StrictMode>
        <RecoilRoot>
          <GlobalStyle />
          <App />
        </RecoilRoot>
      </React.StrictMode>
    );
    ```
    
-   리액트 엄격 모드에서 하는 작업
    
    -  **더 이상 안전하지 않은 특정 생명주기를 사용하는 컴포넌트에 대해 경고**
        
        리액트 클래스 컴포넌트에서 사용되는 생명주기 메서드 중 `componentWillMount`, `componentWillReceiveProps`, `componentWillUpdate`는 더 이상 사용할 수 없게 됐다.
        
        이 메서드들을 사용 && 엄격 모드 -> 경고 발생
        
        _까비엔 위 메서드 사용하는 곳 없넹_
        
    -   **문자열 ref 사용 금지**
        
        과거 리액트에서는 컴포넌트 내부에서 문자열로 ref를 생성하고, 이를 통해 dom 노드를 참조하는 것이 가능했다.
            
        이 방식은 몇 가지 문제가 있어 사용이 금지됐다 -> 엄격 모드에선 경고 발생
            
            리액트 팀이 언급한 문자열 ref의 문제
            
            -   문자열로 값을 주는 것은 여러 컴포넌트에 걸쳐 사용될 수 있으므로 충돌의 여지가 있다.
            -   단순히 문자열이기 때문에 실제로 어떤 ref에서 참조되고 있는지 파악하기 어렵다
            -   리액트가 계속해서 현재 렌더링되고 있는 컴포넌트의 ref의 값을 추적해야하기 때문에 성능 이슈가 있다.
            
    -   **구 Context api 사용 시 경고**
	        
	       구 리액트 context api를 사용하면 → 엄격 모드에선 아래와 같은 에러 발생
   
        _childContextTypes, getChildContext 역시 까비에 없어_
        
    -   **예상치 못한 부작용(side-effects) 검사**
        
        리액트 엄격 모드에선 아래와 같이 순수해야하는 함수, 메서드 등을 의도적으로 이중 호출한다
            
        -   함수 컴포넌트의 body
            
        -   useState, useMemo, useReducer에 전달되는 함수
            
        **엄격 모드에서 두 번씩 실행되는 이유** :
           
           함수형 프로그래밍 원칙에 따라 리액트의 모든 컴포넌트는 항상 순수하다고 가정한다.
           
           엄격 모드에선 모든 컴포넌트가 항상 순수한 결과물을 내고 있는지를 사전에 개발자에게 확인시켜 주기 위해.
           
           만약 안그러면 리액트에선 잠재적으로 버그가 존재할 수 있다고 판단한다.
           
           _오호.. 드디어 2번 실행되는 이유를 알았다. 궁금증 해-소_

            
        -   cf) 엄격 모드에서 console.log 작동 방식
            
            -   리액트 18에서 두 번씩 기록하되, 두 번째 기록은 회색으로 표시하게끔 바뀌었다. (리액트 17과 다름)
            -   엄격 모드에서도 한 번씩 기록되게 하고 싶으면 →
                1.  리액트 개발자 도구 설치
                2.  리액트 개발자 모드에서 `설정 → debugging → hide logs during second render in strict mode` 체크
          
        
        _오 나도 좀 너무 쓸데없이 두 번 출력돼서 확인하고자 하는 내용 파악할때 좀 거슬린다고 생각했는데 이런 의도가 있었구나~ 앞으로는 콘솔 좀 유심히 봐야겠당_
        
-   **리액트 18에서 추가된 기능**
    
    리액트 팀 왈 : 향후 리액트에선 컴포넌트가 마운트 해제된 상태에서 컴포넌트 내부의 상태값을 유지할 수 있는 기능을 제공할 예정

    위 기능을 지원하기 위해 엄격모드에 새로운 기능을 도입했다. 컴포넌트가 최초에 마운트될 때 자동으로 모든 컴포넌트를 마운트 해제하고 → 두 번째 마운트에서 이전 상태를 복원한다. 이 기능은 오직 개발 모드에서만 적용된다
    
    ex)
    
    _옹 신기하다. 왜 마운트되고 바로 마운트 해제하는거지?_
    
    마치 useEffect가 두 번 실행된 것처럼 보이는데, 이건 리액트 18의 strictmode에서 의도된 작동 방식이다. 이에 대해 리액트 팀 왈 :
    
    > 앞으로는 리액트가 상태를 유지하면서 ui의 섹션을 추가하고 제거할 수 있는 기능을 추가하고 싶습니다. ex) 사용자가 화면에서 탭을 눌렀다가 다시 돌아왔을 때 리액트는 이전 화면을 즉시 표시할 수 있어야 합니다. 이를 위해 리액트는 이전과 동일한 컴포넌트 상태를 사용해 → 트리를 마운트 해제하고 다시 마운트 합니다.
    
    이 기능을 사용하면 리액트의 기본 성능이 향상되지만, 컴포넌트가 이펙트를 여러번 마운트 및 제거해도 복원력이 있어야 합니다. 대부분의 이펙트는 변경 없이 작동하지만, 일부 이펙트는 한 번만 마운트되거나 소멸된다고 가정합니다. 이러한 문제를 해결하기 위해 리액트 18에서 엄격 모드에 새로운 검사를 도입했습니다. 이 검사는 컴포넌트가 처음 마운트될 때마다 모든 컴포넌트를 자동으로 마운트 해제하소 → 다시 마운트해서, 두번째 마운트 시 이전 상태로 복원합니다.
    
    _뭔가 캐시와 연관된 것 같기도.._
    
    그러니까, 이후에 있을 변경을 위해 strictmode에서 고의로 useEffect를 두 번 작동시키는 기능을 추가했다.
    
    따라서 미래 리액트 업데이트에 효과적으로 대비하려면 → **useEffect를 사용할 때 반드시 적절한 cleanup 함수를 배치해서 → 반복 실행될 수 있는 useEffect로부터 최대한 자유로운 컴포넌트를 만드는 것이 좋다.**
    
##   10.2.6 suspense 기능 강화

### Suspense

-   컴포넌트를 동적으로 가져올 수 있게 도와준다
    
-   React.lazy를 통해 지연시켜 불러온 컴포넌트를 렌더링한다
    
-   매개변수
    
    -   `fallback`
        -   props
        -   지연시켜 불러올 컴포넌트가 아직 불러오지 못했을때 보여주는 fallback
    -   `children`
        -   으로 React.lazy로 선언한 지연 컴포넌트를 받는다
-   리액트 18 버전에서의 Suspense
    
    -   실험 단계를 벗어나 정식으로 지원된다
    
    -   구체적인 변경 내용
        -   컴포넌트가 실제로 화면에 노출될 때 effect가 실행된다.(이전엔 마운트되기 직전임에도 effect가 실행됨 👎🏻)
            
        -   Suspense로 인해 컴포넌트가 보이거나 사라질 때도 effect가 정상적으로 실행된다. Suspense에 의해
            
            -   노출이 된다면 → useLayoutEffect의 effect(componentDidMount)가
            -   가려진다면 → useLayoutEffect의 cleanup(componentWillUnmount)가
            
            정상적으로 실행된다.
            
            (이전엔 컴포넌트 스스로가 Suspense에 의해 현재 보여지고 있는지, 숨겨졌는지 알 방법이 없었음)
            
            
        -   Suspense 내에 스로틀링이 추가됐다.
            
            화면이 너무 자주 업데이트되어 시각적으로 방해받는 것을 방지하기 위해 → 리액트는 다음 렌더링을 보여주기 전에 잠시 대기한다. 
            
    
    Suspense의 사용이 이전보다 자연스러워졌지만,
    
    -   여전히 Suspense를 사용할 수 있는 시나리오는 제한적인 편이다.
        
        -   React.lazy를 사용해 컴포넌트를 지연시켜 불러올때나
        -   Next js 같이 Suspense를 자체적으로 지원하는 프레임워크에서만
        
        Suspense를 사용하는 것이 가능하다
    

React.lazy와 Suspense는 한 쌍으로 사용됐고, 애플리케이션에서 상대적으로 중요하지 않은 컴포넌트를 분할해서 초기 렌더링 속도를 향상시키는 데 많은 도움을 줬다.


##   10.2.7 인터넷 익스플로러 지원 중단에 따른 추가 폴리필 필요

이제 리액트는 리액트를 사용하는 코드에서 아래와 같은 최신 자스 기능을 사용할 수 있다는 가정을 한다.

-   Promise
-   Symbol
-   Object.assign

위 기능들을 지원하지 않는 브라우저에서 서비스해야 한다면, 이 기능들을 위한 폴리필을 반드시 추가해야한다.

ex) 인터넷 익스플로러 11 환경에서 이 세 가지 폴리필이 설치돼 있지 않다면 → 리액트는 정상적으로 작동하지 않을 수도 있다.

리액트뿐만 아니라 요즘 출시되는 대부분의 라이브러리가 es5 지원을 중단하는 추세 → 만약 웹서비스가 여전히 인터넷 익스플로러 11을 지원해야한다면 → 폴리필 설치 및 트랜스 파일에 각별히 신경 써야 한다.


##   10.2.8 그 밖에 알아두면 좋은 변경사항

-   컴포넌트에서 undefined를 반환해도 에러가 발생하지 않는다. undefined 반환은 null 반환과 동일하게 처리된다
    -   `<Suspense fallback={undefined}>` 도 null과 동일하게 처리된다
-   renderToNodeStream이 지원 중단되고, 대신 renderToPipeableStream 사용이 권장된다


